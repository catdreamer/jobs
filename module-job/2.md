## part2作业  ES新特性与TypeScript、JS性能优化

### 简答题

#### 一、请说出下列最终的执行结果，并解释为什么。

``` javascript
var a = [];
for (var i = 0; i < 10; i++) {
    a[i] = function() {
        console.log(i);
    }
}
a[6]();
```

答：10

​		用 `var` 声明的变量的作用域是它当前的执行上下文，在if或for循环中声明的变量会提升为全局变量，在执行a[i] ()时，i的值已经等于10，故执行a[i] ()时，无论i为(0~9)的任何一个值，打印结果都是10。


#### 二、请说出下列最终的执行结果，并解释为什么。

```
var tmp = 123;
if (true) {
	console.log(tmp);
	let tmp;
}
```

```
答：执行会报错，let的作用域是块级作用域，在if语句中tmp的作用域在{}内，let声明变量temp，变量temp会提升到块级作用域的前面，但未初始化，变量在未定义之前使用，会报错。
```

##### 三、结合ES6新语法，用最简单的方式找出数组中的最小值。

```
var arr = [12, 34, 32, 89, 4];
```

答：
```
var minVal = Math.min(...arr);
console.log(minVal); // 4
```

#### 四、请详细说明var，let，const三种声明变量的方式之间的具体差别。

答：

|   | var                                       | let                                                          | const                                                        |
| :----------------------------------------------------------: | ----------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
|                             声明                             | var a = 9                                 | let a = 9                                                    | const a = 9                                                  |
|                                                              | 可以仅声明不初始化，<br>会默认undefined | 可以仅声明不初始化，<br>会默认undefined                    | 必须在声明时初始化                                           |
|                            作用域                            | 全局作用域、函数作用域                    | 块级作用域                                                   | 块级作用域                                                   |
|                           声明提升                           | 声明提升，且使用<br>undefined初始化     | 仅声明提升，未初始化                                         | 仅声明提升，未初始化                                         |
|                           多次赋值                           | 可以                                      | 可以                                                         | 基本数据类型不可以再次赋值，<br>对象可以改变内部的值和添加属性，<br/>但对象的内存地址不变 |
|                           重复定义                           | 可以重复定义                              | 在相同作用域内不可重复定义，<br>以下代码可执行<br>let temp8 = 8;<br>if (true) {<br>	let temp8 = 9;<br>	console.log(temp8);<br>}<br>console.log(tmep8);<br>// 9<br>// 8 | 在相同作用域内不可重复定义，<br>以下代码可执行<br>const temp9 = 12;<br>if (true) {<br>	const temp9 = 13;<br>	console.log(temp9)<br>} |



#### 五、请说出下列代码最终输出的结果，并解释为什么。

```
var a = 10;
var obj = {
    a: 20,
    fn () {
        setTimeout(() => {
            console.log(this.a);
        });
    }
}
obj.fn();
```
```
答：20 
箭头函数中的this是继承至作用域链的上一层的this，this指向obj，所以执行obj.fn()时，打印的结果为20。
 ```

#### 六、简述Symbol类型的用途。

```
答：symbol是ES6中引入的一种全新的原始数据类型。Symbol()函数会返回Symbol类型的值，有静态属性和静态方法，Symbol不支持new Symbol()语法。Symbol()的每一个值都是独一无二的，不会重复。

基于Symbol的特性，Symbol有如下用途：
(1). 用作对象的key
(2). 使用Symbol来替代常量
(3). 在不知道对象原有属性名的情况下，阻止对象属性名冲突
```
#### 七、说说什么是浅拷贝，什么是深拷贝？
```
答：
浅拷贝：拷贝对象的指针和原对象的指针指向的是同一块内存空间，修改拷贝以后的对象会影响原对象。
深拷贝：拷贝对象的内容，内容地址自助分配，与原数据地址不一样，修改拷贝以后的数据不会影响原数据。
```

#### 八、请简述TypeScript与JavaScript之间的关系。

```
答：TypeScript是有微软开发的开源的编程语言，是JavaScript的一个超集，可以编译出纯净的、简洁的JavaScript代码。
运行环境：Javascript是基于对象和事件驱动的，可以直接在浏览器和node.js环境下运行。而TypeScript需要编译器编译成js。
在TypeScript中可以直接写js代码；TypeScript是为了使Javascript开发变得更加容易创建的。
```

#### 九、请谈谈你认为的TypeScript优缺点。
```
答：优点：
(1). 静态输入，便于开发人员编写代码时检查错误。
(2). 增加了代码的可读性及可维护性。
(3). 类功能更为强大，生态更健全、更完善，利于开发大型项目，方便更好的协同办公。
缺点：
(1). 需要理解一些不太熟悉的概念，增加学习成本，在开发过程中会增加工作量。
```
#### 十、描述引用计数的工作原理和优缺点。
```
答：工作原理：就是让每个被管理的对象与一个引用计数器关联，计数器记录着该对象当前被引用的次数，每创建一个新的引用指向该对象时其计数器就加1，当指向该对象的引用失效时计数器就减1，引用数字变为0立即回收。
优点：内存会及时释放，减少程序卡顿。
缺点：维护引用计数，需要消耗一定资源；循环引用，两个对象相互引用，计数器一直不可能为0，内存永远无法被回收，导致内存泄露。
```
#### 十一、描述标记整理算法的工作流程。
```
答：标记整理算法分为两个阶段：
(1). 标记：遍历GC Roots可达的对象，标记存活的对象。
(2). 整理：移动存活对象，按照内存地址顺序排列在内存中，然后将内存地址末端以后的内存全部回收。
```
#### 十二、描述V8中新生代存储区垃圾回收的流程。
```
答：新生代使用Scarenge算法进行回收，Scarege算法，是把新生代空间分为两个大小相等的区域，一半使用空间(From)，一半空闲空间(To)。创建对象时，先在From空间中进行分配，当进行垃圾回收时，会检查From空间中的存活对象，这些存活对象会被赋值到to空间中，对未存活的对象进行回收，复制完成后，From空间和To空间角色互换。
新生代垃圾回收，有一半内存处于闲置状态，但回收频率高，速度快，以内存的空间换取了时间。
```

#### 十三、描述增量标记算法在何时使用及工作原理。
```
答：增量标记：将标记过程分为多个比较小的子标记，垃圾回收标记与程序交替运行，直到标记阶段完成。
在老生代中，存活对象多，垃圾回收时间长，全停顿世间较长，为了减少全停顿时间，V8对标记进行了优化，将一次停顿标记过程拆分为很多小步标记。
```




























